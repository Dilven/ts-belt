### fromNullable

```ts
function fromNullable<A, B>(value: A, error: NonNullable<B>): Result<ExtractValue<A>, B>
function fromNullable<A, B>(error: NonNullable<B>): (value: A) => Result<ExtractValue<A>, B>
```

### fromFalsy

```ts
function fromFalsy<A, B>(value: A, error: NonNullable<B>): Result<ExtractValue<A>, B>
function fromFalsy<A, B>(error: NonNullable<B>): (value: A) => Result<ExtractValue<A>, B>
```

### fromPredicate

```ts
function fromPredicate<A, B>(value: A, predicateFn: (value: A) => boolean, error: NonNullable<B>): Result<ExtractValue<A>, B>
function fromPredicate<A, B>(predicateFn: (value: A) => boolean, error: NonNullable<B>): (value: A) => Result<ExtractValue<A>, B>
```

### map

```ts
function map<A, B, R>(result: Result<A, B>, mapFn: (value: A) => NonNullable<R>): Result<R, B>
function map<A, B, R>(mapFn: (value: A) => NonNullable<R>): (result: Result<A, B>) => Result<R, B>
```

### mapWithDefault

```ts
function mapWithDefault<A, B, R>(result: Result<A, B>,defaultValue: NonNullable<R>,fn: (value: A) => NonNullable<R>): R
function mapWithDefault<A, B, R>(defaultValue: NonNullable<R>, fn: (value: A) => NonNullable<R>): (result: Result<A, B>) => R
```

### flatMap

```ts
function flatMap<A, B, R>(result: Result<A, B>, mapFn: (value: A) => Result<R, B>): Result<R, B>
function flatMap<A, B, R>(mapFn: (value: A) => Result<R, B>): (result: Result<A, B>) => Result<R, B>
```

### getExn

```ts
function getExn<A, B>(result: Result<A, B>): A | never
```

### getWithDefault

```ts
function getWithDefault<A, B>(result: Result<A, B>, defaultValue: NonNullable<A>): A
function getWithDefault<A, B>(defaultValue: NonNullable<A>): (result: Result<A, B>) => A
```

### toUndefined

```ts
function toUndefined<A, B>(result: Result<A, B>): A | undefined
```

### toNullable

```ts
function toNullable<A, B>(result: Result<A, B>): A | null
```

### toOption

```ts
function toOption<A, B>(result: Result<A, B>): Option<A>
```

### match

```ts
function match<A, B, R>(result: Result<A, B>, okFn: (value: A) => R, errorFn: (value: B) => R): R
function match<A, B, R>(okFn: (value: A) => R, errorFn: (value: B) => R): (result: Result<A, B>) => R
```

### isError

```ts
function isError<A, B>(result: Result<A, B>): result is Error<B>
```

### isOk

```ts
function isOk<A, B>(result: Result<A, B>): result is Ok<A>
```